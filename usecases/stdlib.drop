# Стандартная библиотека Droplet

# ========== Математические функции ==========
# Константы
let pi = 3.1415926535897932 in
let e = 2.7182818284590452 in

# Тригонометрические функции
let sin = flow x -> 
  let rec sinTaylor = flow x n acc term ->
    when n > 10 then 
      acc
    else
      let nextTerm = term * (-1.0) * x * x / (2.0 * n * (2.0 * n + 1.0)) in
      sinTaylor x (n + 1) (acc + nextTerm) nextTerm
  in
  when x == 0.0 then 0.0 else sinTaylor x 1 x x
in

let cos = flow x -> 
  let rec cosTaylor = flow x n acc term ->
    when n > 10 then 
      acc
    else
      let nextTerm = term * (-1.0) * x * x / ((2.0 * n) * (2.0 * n - 1.0)) in
      cosTaylor x (n + 1) (acc + nextTerm) nextTerm
  in
  when x == 0.0 then 1.0 else cosTaylor x 1 1.0 1.0
in

# Функции для работы с числами
let abs = flow x ->
  when x < 0 then -x else x
in

let max = flow a b ->
  when a > b then a else b
in

let min = flow a b ->
  when a < b then a else b
in

let pow = flow x n ->
  let rec powHelper = flow x n acc ->
    when n <= 0 then
      acc
    else
      powHelper x (n - 1) (acc * x)
  in
  powHelper x n 1
in

# Функция для вычисления квадратного корня - метод Ньютона
let sqrt = flow x ->
  let rec sqrtIter = flow guess x ->
    let nextGuess = (guess + x / guess) / 2.0 in
    when abs (nextGuess - guess) < 0.00001 then
      nextGuess
    else
      sqrtIter nextGuess x
  in
  sqrtIter 1.0 x
in

# ========== Списковые функции ==========
# Основные функции для работы со списками
let head = flow list ->
  when list == [] then
    print "Ошибка: пустой список в head"
  else
    list[0]
in

let tail = flow list ->
  when list == [] then
    print "Ошибка: пустой список в tail"
    []
  else
    let rec tailHelper = flow list idx acc ->
      when idx >= length list then
        acc
      else
        tailHelper list (idx + 1) (acc ++ [list[idx]])
    in
    tailHelper list 1 []
in

let length = flow list ->
  let rec lengthHelper = flow list count ->
    when list == [] then
      count
    else
      lengthHelper (tail list) (count + 1)
  in
  lengthHelper list 0
in

# Создание диапазона чисел
let range = flow start end ->
  let rec rangeHelper = flow current end acc ->
    when current > end then
      acc
    else
      rangeHelper (current + 1) end (acc ++ [current])
  in
  rangeHelper start end []
in

# Функциональные преобразования списков
let map = flow f list ->
  let rec mapHelper = flow f list acc ->
    when list == [] then
      acc
    else
      mapHelper f (tail list) (acc ++ [f (head list)])
  in
  mapHelper f list []
in

let filter = flow predicate list ->
  let rec filterHelper = flow pred list acc ->
    when list == [] then
      acc
    else
      let current = head list in
      let newAcc = when pred current then acc ++ [current] else acc in
      filterHelper pred (tail list) newAcc
  in
  filterHelper predicate list []
in

let reduce = flow f initial list ->
  let rec reduceHelper = flow f acc list ->
    when list == [] then
      acc
    else
      reduceHelper f (f acc (head list)) (tail list)
  in
  reduceHelper f initial list
in

let fold = flow f initial list ->
  reduce f initial list
in

let foldRight = flow f list initial ->
  let rec foldRightHelper = flow f list acc ->
    when list == [] then
      acc
    else
      f (head list) (foldRightHelper f (tail list) acc)
  in
  foldRightHelper f list initial
in

let reverse = flow list ->
  let rec reverseHelper = flow list acc ->
    when list == [] then
      acc
    else
      reverseHelper (tail list) ([head list] ++ acc)
  in
  reverseHelper list []
in

let concat = flow list1 list2 ->
  let rec concatHelper = flow list1 list2 ->
    when list1 == [] then
      list2
    else
      [head list1] ++ concatHelper (tail list1) list2
  in
  concatHelper list1 list2
in

# Дополнительные функции для работы со списками
let any = flow predicate list ->
  let rec anyHelper = flow pred list ->
    when list == [] then
      false
    else
      when pred (head list) then
        true
      else
        anyHelper pred (tail list)
  in
  anyHelper predicate list
in

let all = flow predicate list ->
  let rec allHelper = flow pred list ->
    when list == [] then
      true
    else
      when pred (head list) then
        allHelper pred (tail list)
      else
        false
  in
  allHelper predicate list
in

let sum = flow list ->
  reduce (flow a b -> a + b) 0 list
in

let product = flow list ->
  reduce (flow a b -> a * b) 1 list
in

let take = flow n list ->
  let rec takeHelper = flow n list acc ->
    when n <= 0 || list == [] then
      acc
    else
      takeHelper (n - 1) (tail list) (acc ++ [head list])
  in
  takeHelper n list []
in

let drop = flow n list ->
  let rec dropHelper = flow n list ->
    when n <= 0 || list == [] then
      list
    else
      dropHelper (n - 1) (tail list)
  in
  dropHelper n list
in

# ========== Строковые функции ==========
let strLength = flow str ->
  length str
in

let strConcat = flow str1 str2 ->
  str1 + str2
in

let strSplit = flow str separator ->
  let rec splitHelper = flow str sep acc current idx ->
    when idx >= length str then
      when current == "" then acc else acc ++ [current]
    else
      let char = str[idx] in
      when char == sep then
        splitHelper str sep (acc ++ [current]) "" (idx + 1)
      else
        splitHelper str sep acc (current + char) (idx + 1)
  in
  splitHelper str separator [] "" 0
in

let strContains = flow str substr ->
  let rec containsHelper = flow str substr startIdx ->
    when startIdx + length substr > length str then
      false
    else
      let rec checkSubstr = flow str substr idx ->
        when idx >= length substr then
          true
        else
          when str[startIdx + idx] != substr[idx] then
            false
          else
            checkSubstr str substr (idx + 1)
      in
      when checkSubstr str substr 0 then
        true
      else
        containsHelper str substr (startIdx + 1)
  in
  containsHelper str substr 0
in

let strToUpper = flow str ->
  let rec toUpperHelper = flow str acc idx ->
    when idx >= length str then
      acc
    else
      let char = str[idx] in
      let upperChar = when char >= "a" && char <= "z" then 
                       # Преобразуем из нижнего регистра в верхний, манипулируя ASCII
                       let charCode = strToCharCode char in
                       strFromCharCode (charCode - 32)
                     else 
                       char
                     in
      toUpperHelper str (acc + upperChar) (idx + 1)
  in
  toUpperHelper str "" 0
in

let strToLower = flow str ->
  let rec toLowerHelper = flow str acc idx ->
    when idx >= length str then
      acc
    else
      let char = str[idx] in
      let lowerChar = when char >= "A" && char <= "Z" then 
                       # Преобразуем из верхнего регистра в нижний, манипулируя ASCII
                       let charCode = strToCharCode char in
                       strFromCharCode (charCode + 32)
                     else 
                       char
                     in
      toLowerHelper str (acc + lowerChar) (idx + 1)
  in
  toLowerHelper str "" 0
in

let strTrim = flow str ->
  let rec trimLeft = flow str idx ->
    when idx >= length str then
      ""
    else
      when str[idx] == " " || str[idx] == "\t" || str[idx] == "\n" then
        trimLeft str (idx + 1)
      else
        let rec getSubstr = flow str start end acc ->
          when start > end then
            acc
          else
            getSubstr str (start + 1) end (acc + str[start])
        in
        getSubstr str idx (length str - 1) ""
  in
  
  let rec trimRight = flow str ->
    let rec findLastNonSpace = flow str idx ->
      when idx < 0 then
        0
      else
        when str[idx] == " " || str[idx] == "\t" || str[idx] == "\n" then
          findLastNonSpace str (idx - 1)
        else
          idx
    in
    let lastNonSpace = findLastNonSpace str (length str - 1) in
    let rec getSubstr = flow str end acc ->
      when end < 0 then
        acc
      else
        getSubstr str (end - 1) (str[end] + acc)
    in
    getSubstr str lastNonSpace ""
  in
  
  trimRight (trimLeft str 0)
in

# ========== Файловые операции ==========
let readFile = flow path ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _readFile path
in

let writeFile = flow path content ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _writeFile path content
in

let appendFile = flow path content ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _appendFile path content
in

let fileExists = flow path ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _fileExists path
in

# ========== Ввод/вывод ==========
let print = flow msg ->
  # Внутренняя нативная функция для вывода, уже предоставлена
  _print msg
in

let input = flow prompt ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _input prompt
in

let inputInt = flow prompt ->
  let input_str = input prompt in
  strToInt input_str
in

let inputFloat = flow prompt ->
  let input_str = input prompt in
  strToFloat input_str
in

# ========== Утилиты преобразования типов ==========
let strToInt = flow str ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _toInt str
in

let strToFloat = flow str ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _toFloat str
in

let strFromInt = flow int ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _toString int
in

let strFromFloat = flow float ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _toString float
in

# Дополнительные функции для работы с символами
let strToCharCode = flow char ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _charToCode char
in

let strFromCharCode = flow code ->
  # Внутренняя нативная функция, предоставляемая интерпретатором
  _codeToChar code
in

# ========== Функциональные утилиты ==========
let identity = flow x -> x in

let compose = flow f g x -> f (g x) in

let curry = flow f a b -> f (a, b) in

let uncurry = flow f (a, b) -> f a b in

let flip = flow f a b -> f b a in

let apply = flow f x -> f x in

# Конец стандартной библиотеки